// ============================================================================
// settlement.proto - L1↔L2 Settlement Protocol (Production Ready)
// ============================================================================
//
// The Bank (L1) ↔ Casino (L2) Communication Protocol
//
// ARCHITECTURE:
// ┌─────────────────────────────────────────────────────────────────────────┐
// │  L1 (Bank/Vault)              │  L2 (Casino/Gaming)                    │
// │  ─────────────────            │  ───────────────────                   │
// │  • Holds real money           │  • Runs games instantly                │
// │  • Ed25519 sig verification   │  • Tracks bets internally              │
// │  • Final settlement           │  • Sub-second UX                       │
// │  • gRPC server on :50051      │  • gRPC client to L1                   │
// │                               │                                         │
// │  Address: L1_<40hex>          │  Address: L2_<40hex>                   │
// │  (same hash, different layer) │  (same hash, different layer)          │
// └─────────────────────────────────────────────────────────────────────────┘
//
// FLOWS:
//
// === LEGACY FLOW (Dealer Fronting) ===
// 1. User locks funds: L1 debits user, marks as "locked for L2"
// 2. User bets on L2: Dealer fronts stake immediately (great UX)
// 3. L2 requests reimbursement: L1 moves user's locked → Dealer
// 4. Bet resolves: L2 tells L1 outcome, L1 settles Dealer↔User
// 5. User withdraws: L1 unlocks remaining funds
//
// === CREDIT LINE FLOW (Casino Bank Model - CURRENT) ===
// 1. ApproveCreditLine: User signs approval for credit limit (e.g., 500 BB)
// 2. CreditDraw: User signs each L1→L2 transfer (initial + auto-replenish)
// 3. User bets: L2 tracks all bets internally, no L1 calls per bet
// 4. CreditSettle: User signs settlement, L2 balance returns to L1
//    - L2 can ONLY return to SAME wallet that deposited
//    - Net PnL calculated: final_balance - total_drawn
//
// SECURITY:
// - ALL L1 token movements require valid Ed25519 signature
// - L1→L2 transfers require signature EACH TIME (not just approval)
// - L2→L1 returns MUST go to original depositor wallet
// - Domain separation: chain_id prevents L1/L2 replay attacks
// - Nonces prevent replay within same chain
// - Intent hashes bind bet parameters
//
// ============================================================================

syntax = "proto3";

package blackbook.settlement;

option go_package = "github.com/blackbook/settlement";

// ============================================================================
// SETTLEMENT SERVICE - The Bank's gRPC API
// ============================================================================

service SettlementNode {
  // === Core Settlement Operations ===
  rpc ExecuteSettlement(SettlementRequest) returns (SettlementResponse);
  rpc RequestReimbursement(ReimbursementRequest) returns (ReimbursementResponse);
  
  // === Bridge Operations (L1 ↔ L2 Token Movement) ===
  rpc InitiateBridgeLock(BridgeLockRequest) returns (BridgeLockResponse);
  rpc ReleaseBridgeFunds(BridgeReleaseRequest) returns (BridgeReleaseResponse);
  rpc VerifySettlementProof(SettlementProofRequest) returns (SettlementProofResponse);
  
  // === Credit Line Operations (Casino Bank Model) ===
  // SECURITY: All L1 token movements require valid Ed25519 signature
  rpc ApproveCreditLine(CreditApprovalRequest) returns (CreditApprovalResponse);
  rpc CreditDraw(CreditDrawRequest) returns (CreditDrawResponse);
  rpc CreditSettle(CreditSettleRequest) returns (CreditSettleResponse);
  rpc GetCreditStatus(CreditStatusRequest) returns (CreditStatusResponse);
  
  // === Balance Queries ===
  rpc GetBalance(BalanceRequest) returns (BalanceResponse);
  rpc CheckSufficientBalance(SufficientBalanceRequest) returns (SufficientBalanceResponse);
  
  // === Signature Verification (L2 validates L1 signatures) ===
  rpc VerifySignature(SignatureVerifyRequest) returns (SignatureVerifyResponse);
  
  // === Health & Status ===
  rpc HealthCheck(HealthRequest) returns (HealthResponse);
  rpc GetBlockHeight(BlockHeightRequest) returns (BlockHeightResponse);
}

// ============================================================================
// COMMON TYPES
// ============================================================================

// Standard error codes for all responses
enum ErrorCode {
  ERROR_NONE = 0;
  ERROR_INSUFFICIENT_BALANCE = 1;
  ERROR_INVALID_SIGNATURE = 2;
  ERROR_INVALID_NONCE = 3;
  ERROR_EXPIRED_REQUEST = 4;
  ERROR_INVALID_ADDRESS = 5;
  ERROR_LOCK_NOT_FOUND = 6;
  ERROR_ALREADY_SETTLED = 7;
  ERROR_UNAUTHORIZED = 8;
  ERROR_INTERNAL = 99;
}

// Chain identifiers for domain separation
enum ChainId {
  CHAIN_UNKNOWN = 0;
  CHAIN_L1 = 1;      // Layer 1 (Bank/Vault) - Real money
  CHAIN_L2 = 2;      // Layer 2 (Casino/Gaming) - Fast bets
}

// ============================================================================
// SETTLEMENT MESSAGES - Final bet resolution
// ============================================================================

message SettlementRequest {
  // Identity
  string dealer_address = 1;     // L1_<40hex> or L2_<40hex>
  string user_address = 2;       // User's L1 address
  string beneficiary = 3;        // Who receives payout (winner)
  
  // Bet details
  string bet_id = 4;             // Unique bet identifier
  string market_id = 5;          // Market the bet was placed on
  string outcome = 6;            // Resolved outcome (YES/NO/VOID)
  
  // Amounts (in microtokens: 1 BB = 1,000,000 µBB)
  uint64 stake_amount = 7;       // Original stake
  uint64 payout_amount = 8;      // Amount to pay winner
  
  // Cryptographic proof
  string public_key = 10;        // Ed25519 public key (64 hex)
  bytes signature = 11;          // Ed25519 signature
  bytes intent_hash = 12;        // SHA256 of original bet intent
  uint64 nonce = 13;             // Replay protection
  uint64 timestamp = 14;         // Request timestamp (ms since epoch)
  ChainId chain_id = 15;         // Domain separation
}

message SettlementResponse {
  bool success = 1;
  ErrorCode error_code = 2;
  string error_message = 3;
  
  // Transaction details
  string tx_hash = 4;            // L1 transaction hash
  uint64 block_height = 5;       // L1 block height
  
  // Updated balances (in microtokens)
  uint64 dealer_balance = 6;
  uint64 user_balance = 7;
  uint64 beneficiary_balance = 8;
}

// ============================================================================
// REIMBURSEMENT MESSAGES - Casino asks Bank to pay back fronted stake
// ============================================================================

message ReimbursementRequest {
  // Identity
  string dealer_address = 1;     // Dealer requesting reimbursement
  string user_address = 2;       // User whose locked balance to debit
  
  // Bet reference
  string bet_id = 3;             // Reference to the bet
  uint64 amount = 4;             // Amount to reimburse (microtokens)
  
  // Cryptographic proof
  string public_key = 10;        // Dealer's public key
  bytes signature = 11;          // Dealer's signature
  uint64 nonce = 12;
  uint64 timestamp = 13;
  ChainId chain_id = 14;
}

message ReimbursementResponse {
  bool success = 1;
  ErrorCode error_code = 2;
  string error_message = 3;
  
  string tx_hash = 4;
  uint64 user_remaining_locked = 5;  // User's remaining locked balance
  uint64 dealer_credited = 6;        // Amount credited to dealer
}

// ============================================================================
// BRIDGE MESSAGES - L1 ↔ L2 Token Movement
// ============================================================================

message BridgeLockRequest {
  // Identity
  string user_address = 1;       // User's L1 address (L1_<40hex>)
  
  // Lock details
  uint64 amount = 2;             // Amount to lock (microtokens)
  string target_layer = 3;       // "L2" for deposits to L2
  
  // Cryptographic proof
  string public_key = 10;
  bytes signature = 11;
  uint64 nonce = 12;
  uint64 timestamp = 13;
  ChainId chain_id = 14;
}

message BridgeLockResponse {
  bool success = 1;
  ErrorCode error_code = 2;
  string error_message = 3;
  
  string lock_id = 4;            // Unique lock identifier
  uint64 locked_amount = 5;      // Amount successfully locked
  uint64 available_balance = 6;  // Remaining available balance
  uint64 expires_at = 7;         // Lock expiry (unix timestamp)
}

message BridgeReleaseRequest {
  // Lock reference
  string lock_id = 1;
  string user_address = 2;
  
  // Release details
  string beneficiary = 3;        // Who receives the unlocked funds
  uint64 amount = 4;             // Amount to release (microtokens)
  
  // L2 proof (how L1 knows L2 approved this)
  bytes l2_signature = 10;       // L2's signature on the release
  string l2_public_key = 11;     // L2's public key
  uint64 l2_block_height = 12;   // L2 block where this was approved
  
  // Optional context
  string market_id = 20;
  string outcome = 21;
}

message BridgeReleaseResponse {
  bool success = 1;
  ErrorCode error_code = 2;
  string error_message = 3;
  
  string tx_hash = 4;
  uint64 released_amount = 5;
  string recipient = 6;
  uint64 recipient_new_balance = 7;
}

message SettlementProofRequest {
  string lock_id = 1;
  string market_id = 2;
  string outcome = 3;
  string beneficiary = 4;
  uint64 amount = 5;
  bytes l2_signature = 6;
  string l2_public_key = 7;
  uint64 l2_block_height = 8;
}

message SettlementProofResponse {
  bool valid = 1;
  bool release_authorized = 2;
  ErrorCode error_code = 3;
  string error_message = 4;
}

// ============================================================================
// SIGNATURE VERIFICATION - L2 validates user signatures against L1
// ============================================================================

message SignatureVerifyRequest {
  string public_key = 1;         // Ed25519 public key (64 hex)
  string message = 2;            // Original message that was signed
  bytes signature = 3;           // Ed25519 signature (128 hex)
  ChainId expected_chain = 4;    // Which chain the signature should be for
}

message SignatureVerifyResponse {
  bool valid = 1;
  string derived_address = 2;    // L1_<40hex> derived from public key
  ErrorCode error_code = 3;
  string error_message = 4;
}

// ============================================================================
// BALANCE MESSAGES
// ============================================================================

message BalanceRequest {
  string address = 1;            // L1_<40hex> format required
}

message BalanceResponse {
  string address = 1;
  uint64 available = 2;          // Available for transfers (microtokens)
  uint64 locked = 3;             // Locked in bridges (microtokens)
  uint64 total = 4;              // available + locked
  
  // Breakdown by purpose
  uint64 locked_for_l2 = 5;      // Locked for L2 gaming
  uint64 pending_settlement = 6; // In pending settlements
}

message SufficientBalanceRequest {
  string address = 1;
  uint64 required_amount = 2;
  bool check_available_only = 3; // If true, only checks available (not locked)
}

message SufficientBalanceResponse {
  bool sufficient = 1;
  uint64 available = 2;
  uint64 shortfall = 3;          // How much more is needed (0 if sufficient)
}

// ============================================================================
// HEALTH & STATUS MESSAGES
// ============================================================================

message HealthRequest {}

message HealthResponse {
  string status = 1;             // "healthy", "degraded", "unhealthy"
  uint64 block_height = 2;
  string version = 3;
  uint64 uptime_seconds = 4;
  uint32 pending_settlements = 5;
  uint32 active_locks = 6;
  uint64 total_locked_amount = 7;
}

message BlockHeightRequest {}

message BlockHeightResponse {
  uint64 height = 1;
  string blockhash = 2;
  uint64 timestamp = 3;
  string previous_blockhash = 4;
}

// ============================================================================
// CREDIT LINE MESSAGES - Casino Bank Model
// ============================================================================
//
// SECURITY MODEL:
// 1. ANY L1 token movement requires valid Ed25519 signature
// 2. L1→L2 transfers require signature EACH TIME (not just once)
// 3. L2 can ONLY return tokens to the SAME wallet that deposited them
//
// FLOW:
// 1. ApproveCreditLine - User signs to approve a credit limit (e.g., 500 BB)
// 2. CreditDraw - User signs each draw from L1→L2 (initial + replenishments)
// 3. CreditSettle - User signs settlement, unused L2 balance returns to L1
//
// CASINO ANALOGY:
// - Approval = "I authorize up to $500 in chips"
// - Draw = "Give me $100 in chips" (requires signature each time)
// - Settle = "Cash out my remaining chips" (returns to SAME wallet)
// ============================================================================

message CreditApprovalRequest {
  // Identity
  string wallet_address = 1;     // L1_<40hex>
  string public_key = 2;         // Ed25519 public key (64 hex)
  
  // Credit terms
  uint64 credit_limit = 3;       // Maximum drawable amount (microtokens)
  uint64 expires_in_hours = 4;   // How long approval is valid
  
  // Security
  bytes signature = 10;          // Signature of: APPROVE_CREDIT:wallet:limit:nonce
  uint64 nonce = 11;             // Replay protection
  uint64 timestamp = 12;         // Request timestamp (seconds since epoch)
}

message CreditApprovalResponse {
  bool success = 1;
  ErrorCode error_code = 2;
  string error_message = 3;
  
  // Approval details
  string approval_id = 4;        // Unique approval identifier
  string session_id = 5;         // Associated session ID
  uint64 credit_limit = 6;       // Approved limit
  uint64 expires_at = 7;         // Unix timestamp when approval expires
  uint64 l1_balance = 8;         // Current L1 balance
  
  // Session state
  CreditSessionInfo session = 20;
}

message CreditDrawRequest {
  // Identity - REQUIRED for all L1 token movements
  string wallet_address = 1;     // L1_<40hex>
  string public_key = 2;         // Ed25519 public key (64 hex)
  
  // Draw details
  string session_id = 3;         // Credit session ID
  uint64 amount = 4;             // Amount to draw (microtokens)
  string reason = 5;             // "initial", "low_balance", "user_request"
  
  // Security - SIGNATURE REQUIRED FOR EVERY DRAW
  bytes signature = 10;          // Signature of: CREDIT_DRAW:wallet:session:amount:timestamp:nonce
  uint64 timestamp = 11;         // Request timestamp (seconds since epoch)
  string nonce = 12;             // Replay protection (UUID or random string)
}

message CreditDrawResponse {
  bool success = 1;
  ErrorCode error_code = 2;
  string error_message = 3;
  
  // Draw result
  uint64 amount_drawn = 4;       // Amount transferred L1→L2
  uint64 l1_before = 5;          // L1 balance before draw
  uint64 l1_after = 6;           // L1 balance after draw
  
  // Updated session state
  uint64 l2_balance = 10;        // New L2 balance
  uint64 remaining_credit = 11;  // Remaining drawable credit
  uint32 draw_count = 12;        // Total draws in this session
}

message CreditSettleRequest {
  // Session reference
  string session_id = 1;
  
  // Identity - MUST match session's original wallet
  // SECURITY: L2 can ONLY return tokens to the SAME wallet that deposited
  string wallet_address = 2;     // Must match session.wallet_address
  string public_key = 3;         // Ed25519 public key (64 hex)
  
  // Settlement details
  uint64 final_l2_balance = 4;   // Remaining L2 balance to return
  uint64 locked_in_bets = 5;     // Amount still locked in open positions
  
  // Security - SIGNATURE REQUIRED FOR SETTLEMENT
  bytes signature = 10;          // Signature of: CREDIT_SETTLE:session:wallet:balance:timestamp:nonce
  uint64 timestamp = 11;         // Request timestamp (seconds since epoch)
  string nonce = 12;             // Replay protection
}

message CreditSettleResponse {
  bool success = 1;
  ErrorCode error_code = 2;
  string error_message = 3;
  
  // Settlement result
  string settlement_type = 4;    // "WINNINGS", "LOSSES", "BREAK_EVEN"
  int64 net_pnl = 5;             // Net profit/loss (can be negative)
  
  // Session summary
  uint64 total_drawn = 10;       // Total amount drawn during session
  uint64 final_l2_balance = 11;  // Amount returned to L1
  uint64 locked_in_bets = 12;    // Amount still locked
  uint32 draw_count = 13;        // Total draws in session
  
  // Balance changes
  uint64 l1_before = 20;         // L1 balance before settlement
  uint64 l1_after = 21;          // L1 balance after settlement
  uint64 returned_to_l1 = 22;    // Amount returned from L2
}

message CreditStatusRequest {
  string wallet_address = 1;     // L1_<40hex>
}

message CreditStatusResponse {
  bool success = 1;
  ErrorCode error_code = 2;
  string error_message = 3;
  
  // Current state
  string wallet_address = 4;
  uint64 l1_balance = 5;         // Current L1 balance
  bool has_active_credit = 6;    // Has active credit approval
  
  // Credit approval (if exists)
  CreditApprovalInfo approval = 10;
  
  // Active session (if exists)
  CreditSessionInfo session = 20;
  
  // Global stats
  uint64 total_credit_extended = 30;
  uint32 total_draws = 31;
  uint32 total_settlements = 32;
}

// Helper message types
message CreditApprovalInfo {
  string approval_id = 1;
  uint64 credit_limit = 2;
  uint64 total_drawn = 3;
  uint64 remaining_credit = 4;
  bool is_active = 5;
  uint64 expires_at = 6;         // Unix timestamp
}

message CreditSessionInfo {
  string session_id = 1;
  uint64 l2_balance = 2;         // Current L2 balance
  uint64 locked_in_bets = 3;     // Amount locked in open positions
  uint64 available_to_bet = 4;   // l2_balance - locked_in_bets
  uint64 total_drawn = 5;        // Total drawn during session
  uint32 draw_count = 6;         // Number of draws
  bool is_active = 7;
}
