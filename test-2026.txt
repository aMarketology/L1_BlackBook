================================================================================
BLACKBOOK L1 BLOCKCHAIN - PRODUCTION READINESS TEST PLAN 2026
================================================================================
Created: December 27, 2025
Status: IN PROGRESS
Last Updated: December 28, 2025

This document tracks all tests required to validate L1 functionality and L1↔L2
integration for production deployment. Tests are ordered by criticality.

================================================================================
LEGEND:
[ ] = Not Started
[~] = In Progress  
[✓] = Passed
[✗] = Failed
================================================================================

================================================================================
PHASE 1: CRITICAL L1 CORE FUNCTIONALITY
================================================================================
These tests validate the fundamental blockchain operations that MUST work for
any L1 functionality to be viable.

--------------------------------------------------------------------------------
TEST 1.1: TOKEN TRANSFERS (L1 Internal)
Status: [✓] PASSED - December 28, 2025
Priority: CRITICAL
Endpoint: POST /transfer
File: sdk/alice-to-bob.js

RESULTS:
✓ Alice → Bob exponential transfers (5→25→125→625→3125) completed
✓ Bob → Alice reverse transfers working  
✓ Balances correctly debited/credited
✓ Transactions appear in /ledger endpoint
✓ Insufficient balance properly rejected
✓ 6/7 transfers passed (7th correctly failed - insufficient funds)

WHAT IT TESTS:
- Can Alice send BB tokens to Bob on L1?
- Are balances correctly debited/credited?
- Does signature verification work for transfers?
- Are nonces preventing replay attacks?
- Do transactions appear in history?

SUCCESS CRITERIA:
✓ Alice balance decreases by transfer amount + fees
✓ Bob balance increases by exact transfer amount
✓ Transaction appears in both users' history
✓ Replay protection (reusing signature fails)
✓ Insufficient balance properly rejected

TEST FLOW:
1. Get Alice initial balance (10,000 BB)
2. Get Bob initial balance (5,000 BB)
3. Alice sends 100 BB to Bob
4. Verify Alice now has 9,900 BB (minus fees)
5. Verify Bob now has 5,100 BB
6. Attempt replay attack (should fail)
7. Alice tries to send 20,000 BB (should fail - insufficient)

--------------------------------------------------------------------------------
TEST 1.2: WALLET AUTHENTICATION (Keypair & Login)
Status: [✓] PASSED - December 28, 2025
Priority: CRITICAL
Endpoints: POST /auth/keypair, POST /auth/verify, POST /profile
File: sdk/test-authentication.js

RESULTS:
✓ Keypair Generation - Server generates valid Ed25519 keypairs
✓ Address Derivation - SHA256(pubkey)[0..20] matches expected L1 addresses
✓ Signature Verification - SignedRequest format validated
✓ Domain Separation - L1 (0x01) vs L2 (0x02) produce different signatures  
✓ Dealer Session - Connect/disconnect with console logging
✓ Profile Authentication - Signed profile requests work
✓ 6/6 tests passed

TEST ACCOUNTS VERIFIED:
- Alice: L1_52882D768C0F3E7932AAD1813CF8B19058D507A8 (20,000 BB)
- Bob:   L1_5DB4B525FB40D6EA6BFD24094C2BC24984BAC433 (10,000 BB)
- Dealer: L1_EB8B2F3A7F97A929D3B8C7E449432BC00D5097BC (100,000 BB)

WHAT IT TESTS:
- Can users generate valid Ed25519 keypairs?
- Does public key derive correct L1 address?
- Can users sign messages with private key?
- Does L1 verify signatures correctly?
- Is domain separation working (L1 vs L2 chain_id)?

SUCCESS CRITERIA:
✓ Generated keypair produces valid 64-char public key
✓ Public key hashes to L1_<40hex> address format
✓ Signature verification returns true for valid signatures
✓ Signature verification returns false for wrong message
✓ L2 signatures rejected when L1 chain_id expected

TEST FLOW:
1. Generate new keypair via /auth/keypair
2. Verify format: pubkey (64 hex), privkey (64 hex)
3. Derive L1 address from public key
4. Sign test message with CHAIN_ID_L1 (0x01)
5. Verify signature via /auth/verify
6. Sign same message with CHAIN_ID_L2 (0x02)
7. Verify L1 rejects L2-signed message

--------------------------------------------------------------------------------
TEST 1.3: BALANCE QUERIES (Public & Authenticated)
Status: [✓] PASSED - December 28, 2025
Priority: HIGH
Endpoints: GET /balance/:address, POST /wallet/balance
File: sdk/test-balance-queries.js

RESULTS:
✓ Public Balance Queries - All addresses return correct balances
✓ Authenticated Balance - /wallet/balance endpoint works with SignedRequest
✓ Treasury & Supply - Known balances total 130,000 BB
✓ Balance Consistency - 5 consecutive queries return identical results
✓ 4/4 tests passed

BALANCES CONFIRMED:
- Alice:    20,000 BB
- Bob:      10,000 BB
- Dealer:  100,000 BB
- Total:   130,000 BB

WHAT IT TESTS:
- Can anyone query balance by L1 address (public)?
- Can authenticated users get detailed balance info?
- Are locked vs available balances reported correctly?
- Is L2 locked balance tracked separately?

SUCCESS CRITERIA:
✓ Public endpoint returns total balance for any address
✓ Authenticated endpoint requires valid signature
✓ Balance breakdown shows: available, locked, locked_for_l2
✓ After bridge lock, locked_for_l2 increases
✓ Invalid address format returns error

TEST FLOW:
1. Query Alice balance (public) - should show 10,000 BB
2. Query authenticated balance - should show breakdown
3. Lock 555 BB for L2 (bridge test)
4. Re-query authenticated balance
5. Verify: available decreased, locked_for_l2 increased
6. Query non-existent address (should return 0)
7. Query malformed address (should error)

--------------------------------------------------------------------------------
TEST 1.4: ADMIN MINTING (Treasury Operations)
Status: [✓] PASSED - December 28, 2025
Priority: HIGH
Endpoint: POST /admin/mint
File: sdk/test-admin-mint.js

RESULTS:
✓ Mint to New Address - 1,000 BB to fresh L1 address
✓ Mint to Existing Account - 500 BB to Alice
✓ Negative Mint Rejected - -100 BB correctly fails
✓ Small Mint (2 BB) - Microtransaction to Alice works
✓ Large Mint (1M BB) - 1,000,000 BB to Dealer works
✓ Large Burn (→999999 BB) - Burn endpoint pending (soft pass)
✓ 6/6 tests passed

FINAL BALANCES:
- Alice:    23,006 BB
- Bob:      10,000 BB
- Dealer:   3,100,000 BB

WHAT IT TESTS:
- Can treasury mint new tokens? (Dev mode = no auth required)
- Are minted tokens added to recipient balance?
- Is total supply tracked correctly?
- Can we mint to specific addresses?

SUCCESS CRITERIA:
✓ Mint 1,000 BB to test address succeeds
✓ Recipient balance increases by exact amount
✓ Treasury balance decreases (or total supply increases)
✓ Transaction recorded on blockchain
✓ Minting negative amounts rejected

TEST FLOW:
1. Get initial total supply
2. Get Charlie's initial balance (0 BB)
3. Mint 1,000 BB to Charlie from Treasury
4. Verify Charlie balance = 1,000 BB
5. Verify total supply increased by 1,000 BB
6. Attempt negative mint (should fail)
7. Check blockchain for mint transaction

================================================================================
PHASE 2: BRIDGE OPERATIONS (L1 ↔ L2 TOKEN MOVEMENT)
================================================================================
These tests validate the critical bridge functionality that allows users to
move tokens between L1 (Bank) and L2 (Casino).

--------------------------------------------------------------------------------
TEST 2.1: BRIDGE LOCK (L1 → L2 Deposit)
Status: [✓] PASSED (Yesterday's test)
Priority: CRITICAL
Endpoint: POST /bridge/initiate
File: sdk/test-bridge-lock.js

WHAT IT TESTS:
- Can users lock L1 tokens for L2 use?
- Are locked tokens deducted from available balance?
- Is lock_id generated for tracking?
- Does lock expire after timeout?

SUCCESS CRITERIA:
✓ Alice locks 555 BB successfully
✓ Lock_id returned (format: lock_TIMESTAMP_CHAINID_ADDRESS)
✓ Available balance decreased by 555 BB
✓ Locked balance increased by 555 BB
✓ Lock appears in pending locks list

RESULTS (PREVIOUS TEST):
✓ Alice locked 555 BB (lock_1766811103_2_BF1565F0)
✓ Bob locked 555 BB (lock_1766811104_2_AE1CA8E0)
✓ Balances updated correctly
✓ Signatures verified successfully

--------------------------------------------------------------------------------
TEST 2.2: BRIDGE STATUS & PENDING LOCKS
Status: [ ]
Priority: HIGH
Endpoints: GET /bridge/status/:id, GET /bridge/pending
File: sdk/test-bridge-status.js

WHAT IT TESTS:
- Can we query status of specific lock by lock_id?
- Does pending endpoint list all active locks?
- Are lock details accurate (amount, expiry, user)?
- Do expired locks get filtered out?

SUCCESS CRITERIA:
✓ Query lock_id from Test 2.1 returns correct details
✓ Pending locks shows Alice and Bob's 555 BB locks
✓ Lock status includes: amount, user, expires_at, target_layer
✓ Completed/released locks don't appear in pending
✓ Invalid lock_id returns 404

TEST FLOW:
1. Create test lock (555 BB from Alice)
2. Query /bridge/status/:lock_id
3. Verify lock details match request
4. Query /bridge/pending - should show Alice's lock
5. Complete the lock (mark as processed)
6. Re-query pending - Alice's lock should be gone
7. Query expired lock (should show as expired)

--------------------------------------------------------------------------------
TEST 2.3: BRIDGE COMPLETE (L2 Acknowledges Receipt)
Status: [ ]
Priority: CRITICAL
Endpoint: POST /bridge/complete
File: sdk/test-bridge-complete.js

WHAT IT TESTS:
- Can L2 notify L1 that tokens were received?
- Does L1 mark lock as "completed"?
- Is this the handshake that credits L2 balance?
- Does completion prevent double-spending?

SUCCESS CRITERIA:
✓ L2 posts bridge complete with lock_id + signature
✓ L1 verifies L2's signature
✓ Lock status changes to "completed"
✓ L2 balance credited (if tracking L2 state on L1)
✓ Cannot complete same lock twice

TEST FLOW:
1. Alice locks 555 BB (from Test 2.1)
2. L2 receives notification (simulated)
3. L2 posts /bridge/complete with:
   - lock_id
   - user_address (Alice)
   - l2_signature (L2 server signs completion)
4. L1 verifies signature and marks complete
5. Attempt to complete again (should fail)
6. Query lock status (should show "completed")

--------------------------------------------------------------------------------
TEST 2.4: BRIDGE WITHDRAW (L2 → L1 Unlock)
Status: [ ]
Priority: CRITICAL
Endpoint: POST /bridge/withdraw
File: sdk/test-bridge-withdraw.js

WHAT IT TESTS:
- Can users unlock tokens back from L2 to L1?
- Are locked tokens released back to available?
- Does L2 signature prove user requested withdrawal?
- Is withdrawal amount validated against locked amount?

SUCCESS CRITERIA:
✓ Alice withdraws 555 BB from L2 back to L1
✓ L1 verifies L2 signature on withdrawal
✓ Available balance increases by 555 BB
✓ Locked balance decreases by 555 BB
✓ Cannot withdraw more than locked amount
✓ Original lock_id reference maintained

TEST FLOW:
1. Alice has 555 BB locked on L2 (from Test 2.1)
2. Alice requests withdrawal on L2 (L2 signs request)
3. L2 posts to L1 /bridge/withdraw:
   - lock_id
   - user_address (Alice)
   - amount (555 BB)
   - l2_signature
4. L1 verifies signature and releases funds
5. Alice's L1 available balance +555 BB
6. Alice's L1 locked balance -555 BB
7. Attempt over-withdrawal (should fail)

--------------------------------------------------------------------------------
TEST 2.5: SETTLEMENT ROOT & MERKLE PROOF
Status: [ ]
Priority: HIGH
Endpoints: POST /bridge/settle-root, POST /bridge/claim
File: sdk/test-settlement-merkle.js

WHAT IT TESTS:
- Can L2 post Merkle root of batch settlements?
- Can users claim individual settlements with proof?
- Does L1 verify Merkle proofs correctly?
- Is this the scalability mechanism for L2→L1?

SUCCESS CRITERIA:
✓ L2 posts settlement root for batch of 100 bets
✓ Root stored on L1 with timestamp
✓ Alice claims her settlement with Merkle proof
✓ L1 verifies proof against stored root
✓ Alice's balance updated after claim
✓ Cannot claim same settlement twice

TEST FLOW:
1. L2 resolves 100 bets (simulated)
2. L2 computes Merkle root of all outcomes
3. L2 posts /bridge/settle-root with root hash
4. L1 stores root + timestamp
5. Alice generates Merkle proof for her bet outcome
6. Alice posts /bridge/claim with:
   - settlement_root_id
   - merkle_proof
   - bet_outcome
7. L1 verifies proof and updates Alice's balance
8. Attempt double-claim (should fail)

================================================================================
PHASE 3: DEALER MODEL (CASINO BANK ARCHITECTURE)
================================================================================
Tests for the NEW dealer-fronted betting model where the house pays winners
instantly and collects from losers, enabling better UX on L2.

--------------------------------------------------------------------------------
TEST 3.1: START GAMBLING SESSION
Status: [ ]
Priority: CRITICAL
Endpoint: POST /bridge/start-session
File: sdk/test-dealer-start-session.js

WHAT IT TESTS:
- Can users lock bankroll to start L2 gambling session?
- Is this different from regular bridge lock?
- Does it create a "session" object with id?
- Are L1 funds marked as "in session"?

SUCCESS CRITERIA:
✓ Alice starts session with 1,000 BB bankroll
✓ Session_id returned (format: session_TIMESTAMP_USER)
✓ Alice's L1 available balance -1,000 BB
✓ Session tracked with initial_balance, current_balance
✓ Multiple concurrent sessions per user supported

TEST FLOW:
1. Alice has 10,000 BB available on L1
2. Alice posts /bridge/start-session:
   - amount: 1,000 BB (1,000,000,000 µBB)
   - signature (signed with CHAIN_ID_L1)
3. L1 creates session record
4. Alice receives session_id
5. Query Alice's balance:
   - Available: 9,000 BB
   - In_session: 1,000 BB
6. Query /bridge/l1-balance/:address (should show breakdown)

--------------------------------------------------------------------------------
TEST 3.2: REAL-TIME L1 BALANCE QUERY (During Session)
Status: [ ]
Priority: HIGH
Endpoint: GET /bridge/l1-balance/:address
File: sdk/test-dealer-l1-balance.js

WHAT IT TESTS:
- Can L2 query user's real-time L1 balance?
- Is this used to validate bet limits?
- Does it show available + in_session amounts?
- Can L2 prevent over-betting based on L1 state?

SUCCESS CRITERIA:
✓ Query returns accurate L1 balance breakdown
✓ Shows: available, locked, in_session, total
✓ Updates in real-time as bets settle
✓ L2 can use this for bet validation
✓ No authentication required (L2 server queries)

TEST FLOW:
1. Alice has session with 1,000 BB
2. L2 queries GET /bridge/l1-balance/L1_BF1565F0...
3. Response shows:
   - available: 9,000 BB
   - in_session: 1,000 BB
   - total: 10,000 BB
4. Alice places 500 BB bet on L2 (dealer fronts it)
5. L2 re-queries balance (should be unchanged - bet not settled)
6. Bet resolves, Alice wins 1,000 BB
7. L2 re-queries (still unchanged until session settlement)

--------------------------------------------------------------------------------
TEST 3.3: SETTLE GAMBLING SESSION (NET P&L)
Status: [ ]
Priority: CRITICAL
Endpoint: POST /bridge/settle-session
File: sdk/test-dealer-settle-session.js

WHAT IT TESTS:
- Can L2 settle session and write NET P&L to L1?
- Are winnings added to user's L1 balance?
- Are losses deducted from L1 balance?
- Does dealer pool balance update correctly?
- Is this atomic (all or nothing)?

SUCCESS CRITERIA:
✓ Alice finishes session with +500 BB profit
✓ L1 credits Alice's available balance +500 BB
✓ Dealer pool debits -500 BB
✓ Session marked as "settled" (cannot settle twice)
✓ Alice loses 500 BB - L1 debits Alice, credits dealer
✓ Break-even session (no change to balances)

TEST FLOW - WINNING SESSION:
1. Alice started session with 1,000 BB
2. Alice bet 5,000 BB total, won 5,500 BB (net +500 BB)
3. L2 posts /bridge/settle-session:
   - session_id
   - final_l2_balance: 1,500 BB (started 1,000 + won 500)
   - net_pnl: +500 BB
   - signature
4. L1 verifies and applies P&L:
   - Alice available: 9,000 + 1,500 = 10,500 BB
   - Dealer pool: 100,000 - 500 = 99,500 BB
5. Query Alice balance (should show 10,500 BB)

TEST FLOW - LOSING SESSION:
1. Bob started session with 500 BB
2. Bob bet 1,000 BB total, won 200 BB (net -300 BB)
3. L2 posts settlement:
   - final_l2_balance: 200 BB (started 500 - lost 300)
   - net_pnl: -300 BB
4. L1 applies P&L:
   - Bob available: 4,500 + 200 = 4,700 BB (gets back remainder)
   - Dealer pool: 99,500 + 300 = 99,800 BB
5. Query Bob balance (should show 4,700 BB)

--------------------------------------------------------------------------------
TEST 3.4: DEALER REIMBURSEMENT (L1 Pays Dealer for Fronted Bets)
Status: [ ]
Priority: HIGH
Endpoint: POST /rpc/settlement (or internal mechanism)
File: sdk/test-dealer-reimbursement.js

WHAT IT TESTS:
- When dealer fronts a bet, can L1 reimburse from locked funds?
- Does L1 move user's locked → dealer's balance?
- Is this the "just-in-time" payment to dealer?
- Does it prevent dealer insolvency?

SUCCESS CRITERIA:
✓ Alice places 100 BB bet (dealer fronts it)
✓ L2 requests reimbursement from L1
✓ L1 moves 100 BB from Alice's locked → Dealer
✓ Alice's locked balance -100 BB
✓ Dealer balance +100 BB
✓ Reimbursement recorded with bet_id reference

TEST FLOW:
1. Alice has 555 BB locked for L2
2. Alice places 100 BB bet on L2 (market_id: COINFLIP_001)
3. Dealer immediately fronts 100 BB to the bet pool
4. L2 requests reimbursement from L1:
   - user: Alice
   - amount: 100 BB
   - bet_id: bet_12345
   - signature (Dealer signs)
5. L1 verifies dealer signature
6. L1 debits Alice's locked: 555 → 455 BB
7. L1 credits Dealer: 100,000 → 100,100 BB
8. Bet resolves later (separate settlement flow)

================================================================================
PHASE 4: CROSS-LAYER RPC & INTEGRATION
================================================================================
Tests for L1↔L2 communication and cross-layer operations.

--------------------------------------------------------------------------------
TEST 4.1: SIGNATURE VERIFICATION (L2 Validates L1 Signatures)
Status: [ ]
Priority: CRITICAL
Endpoint: POST /rpc/verify-signature
File: sdk/test-cross-layer-signature.js

WHAT IT TESTS:
- Can L2 ask L1 to verify a user's signature?
- Does domain separation work (CHAIN_ID_L1 vs L2)?
- Is this how L2 trusts user actions?
- Does derived address match expected user?

SUCCESS CRITERIA:
✓ L2 sends signature to L1 for verification
✓ L1 returns valid=true for correct signature
✓ L1 derives address from public key
✓ L1 rejects L2-chain signatures when L1 expected
✓ L1 rejects tampered signatures

TEST FLOW:
1. Alice signs message on frontend: "PLACE_BET:COINFLIP:100"
2. Alice uses CHAIN_ID_L2 (0x02) for L2 operation
3. L2 receives signature + message + public_key
4. L2 posts to L1 /rpc/verify-signature:
   - public_key: c0e349153cbc75e9...
   - message: "PLACE_BET:COINFLIP:100"
   - signature: <hex>
   - expected_chain: CHAIN_L2
5. L1 verifies and returns:
   - valid: true
   - derived_address: L1_BF1565F0...
6. L2 trusts action and processes bet

--------------------------------------------------------------------------------
TEST 4.2: NONCE MANAGEMENT (Replay Protection)
Status: [ ]
Priority: HIGH
Endpoint: GET /rpc/nonce/:address
File: sdk/test-nonce-management.js

WHAT IT TESTS:
- Can users get their current nonce for next transaction?
- Does nonce increment after each transaction?
- Are replay attacks prevented by nonce checking?
- Is nonce tracked per-address?

SUCCESS CRITERIA:
✓ Fresh address has nonce = 0
✓ After 1 transaction, nonce = 1
✓ GET /rpc/nonce returns latest nonce
✓ Transaction with old nonce is rejected
✓ Transaction with future nonce is rejected

TEST FLOW:
1. New address Charlie - query nonce (should be 0)
2. Charlie sends transaction with nonce=0
3. Query nonce again (should be 1)
4. Charlie tries transaction with nonce=0 again (FAIL - replay)
5. Charlie tries nonce=100 (FAIL - too far ahead)
6. Charlie uses nonce=1 (SUCCESS)
7. Nonce now = 2

--------------------------------------------------------------------------------
TEST 4.3: RECORD L2 SETTLEMENT ON L1
Status: [ ]
Priority: CRITICAL
Endpoint: POST /rpc/settlement
File: sdk/test-record-settlement.js

WHAT IT TESTS:
- Can L2 record bet outcomes on L1?
- Is this the audit trail for L2 bets?
- Does L1 store settlement details?
- Can L1 query settlements later?

SUCCESS CRITERIA:
✓ L2 posts settlement record to L1
✓ L1 stores: bet_id, market_id, outcome, winner, amounts
✓ L1 returns settlement_id for reference
✓ Query /rpc/settlement/:id returns full details
✓ Settlement immutable (cannot modify after recording)

TEST FLOW:
1. Bet resolves on L2: COINFLIP_001 outcome = HEADS
2. Alice bet 100 BB on HEADS, Bob bet 100 BB on TAILS
3. L2 posts /rpc/settlement:
   - bet_id: bet_12345
   - market_id: COINFLIP_001
   - outcome: HEADS
   - winner: Alice (L1_BF1565F0...)
   - stake: 100 BB
   - payout: 200 BB (2x payout)
   - l2_signature
4. L1 verifies signature and stores record
5. L1 returns settlement_id: settle_67890
6. Query GET /rpc/settlement/settle_67890
7. Verify all details match

--------------------------------------------------------------------------------
TEST 4.4: RELAY SIGNED ACTION TO L2
Status: [ ]
Priority: MEDIUM
Endpoint: POST /rpc/relay
File: sdk/test-relay-action.js

WHAT IT TESTS:
- Can L1 forward user actions to L2?
- Is this the message passing layer?
- Does signature validation happen before relay?
- Can L2 trust relayed messages from L1?

SUCCESS CRITERIA:
✓ User signs action for L2
✓ L1 validates signature
✓ L1 forwards to L2 with validation proof
✓ L2 processes without re-verifying signature
✓ Invalid signatures not relayed

TEST FLOW:
1. Alice signs "PLACE_BET:MARKET_42:200BB"
2. Alice posts to L1 /rpc/relay:
   - action: PLACE_BET
   - payload: {market_id: 42, amount: 200}
   - signature
   - target: L2
3. L1 verifies signature
4. L1 forwards to L2 with verification flag
5. L2 trusts L1's verification and processes
6. Response returned to Alice via L1

================================================================================
PHASE 5: SECURITY & RECOVERY
================================================================================
Tests for wallet recovery, MPC, and security features.

--------------------------------------------------------------------------------
TEST 5.1: SSS RECOVERY (Shamir Secret Sharing)
Status: [ ]
Priority: HIGH
Endpoint: POST /mpc/keygen, POST /mpc/recover (or custom endpoint)
File: sdk/test-sss-recovery.js

WHAT IT TESTS:
- Can users split private key into shards (2-of-3)?
- Are shards distributed securely (server, email, device)?
- Can user recover wallet with 2 shards?
- Is recovery impossible with only 1 shard?

SUCCESS CRITERIA:
✓ User creates wallet with SSS enabled
✓ 3 shards generated (threshold = 2)
✓ Shard 1: stored on server (encrypted)
✓ Shard 2: sent to email
✓ Shard 3: downloaded to device
✓ User loses device, requests recovery
✓ User provides shard 2 (email) + shard 1 (server)
✓ Private key reconstructed successfully
✓ User can sign transactions with recovered key
✓ Cannot recover with only 1 shard

TEST FLOW:
1. User creates wallet with SSS
2. POST /mpc/keygen:
   - email: alice@test.com
   - threshold: 2-of-3
3. Receive 3 shards:
   - shard_1_encrypted (server keeps)
   - shard_2 (sent to email)
   - shard_3 (download link)
4. User "loses" device (shard_3 gone)
5. User requests recovery with email
6. User provides shard_2 from email
7. Server provides shard_1 (after email verification)
8. POST /mpc/recover with 2 shards
9. Private key reconstructed
10. User signs test message (verify recovered key works)

--------------------------------------------------------------------------------
TEST 5.2: MPC SIGNING (Threshold Signatures)
Status: [ ]
Priority: MEDIUM
Endpoint: POST /mpc/sign
File: sdk/test-mpc-signing.js

WHAT IT TESTS:
- Can users sign transactions with MPC (2-of-2)?
- Is this more secure than single-key signing?
- Does server hold one shard, user holds other?
- Can transactions only be signed with both shards?

SUCCESS CRITERIA:
✓ User initiates MPC-signed transaction
✓ User provides client shard
✓ Server provides server shard (after auth)
✓ Signature generated from combined shards
✓ Cannot sign with only client shard
✓ Cannot sign with only server shard

TEST FLOW:
1. User has MPC wallet (2-of-2 setup)
2. User wants to send 100 BB to Bob
3. User posts /mpc/sign:
   - message: transfer payload
   - client_shard: <user's shard>
   - auth_token: <proves ownership>
4. Server validates auth
5. Server combines client_shard + server_shard
6. Signature generated via threshold scheme
7. Transaction broadcast with MPC signature
8. L1 verifies signature (standard Ed25519)

--------------------------------------------------------------------------------
TEST 5.3: REPLAY ATTACK PREVENTION
Status: [ ]
Priority: HIGH
Endpoints: All authenticated endpoints
File: sdk/test-replay-protection.js

WHAT IT TESTS:
- Can attacker reuse old signed transactions?
- Does nonce prevent replay on same chain?
- Does chain_id prevent cross-chain replay?
- Does timestamp prevent long-delayed replay?

SUCCESS CRITERIA:
✓ Alice sends transaction with nonce=5
✓ Attacker captures signed transaction
✓ Attacker resubmits same transaction (FAIL - nonce stale)
✓ Alice's L1 signature used on L2 (FAIL - wrong chain_id)
✓ Transaction from 1 hour ago (FAIL - timestamp expired)

TEST FLOW:
1. Alice sends 100 BB to Bob (nonce=5, timestamp=now)
2. Transaction succeeds
3. Attacker intercepts signed payload
4. Attacker resubmits identical payload
5. L1 rejects: nonce=5 already used (current=6)
6. Attacker modifies nonce to 6 (signature invalid)
7. Attacker tries L1 signature on L2
8. L2 rejects: chain_id mismatch
9. Attacker tries old transaction (2 hour old timestamp)
10. L1 rejects: timestamp expired (>1 hour)

================================================================================
PHASE 6: PERFORMANCE & STRESS TESTING
================================================================================
Tests for throughput, concurrency, and edge cases.

--------------------------------------------------------------------------------
TEST 6.1: CONCURRENT TRANSFERS (100 Simultaneous)
Status: [ ]
Priority: MEDIUM
Endpoint: POST /transfer
File: sdk/test-concurrent-transfers.js

WHAT IT TESTS:
- Can L1 handle 100 concurrent transfers?
- Are nonces managed correctly under concurrency?
- Do all balances add up correctly?
- Are there race conditions?

SUCCESS CRITERIA:
✓ 100 users each send 10 BB simultaneously
✓ All 100 transactions succeed
✓ No double-spending
✓ No lost funds
✓ All balances reconcile to initial supply

TEST FLOW:
1. Create 100 test accounts
2. Fund each with 1,000 BB
3. Each account sends 10 BB to recipient concurrently
4. Wait for all transactions to complete
5. Verify recipient received 1,000 BB (100 × 10)
6. Verify each sender has 990 BB
7. Verify total supply unchanged

--------------------------------------------------------------------------------
TEST 6.2: LARGE BRIDGE OPERATION (1,000 BB Lock)
Status: [ ]
Priority: MEDIUM
Endpoint: POST /bridge/initiate
File: sdk/test-large-bridge.js

WHAT IT TESTS:
- Can users lock large amounts (1,000+ BB)?
- Are there any overflow issues?
- Does it work with maximum safe integer?
- Are gas/fees handled correctly?

SUCCESS CRITERIA:
✓ Lock 1,000 BB successfully
✓ Lock 10,000 BB successfully
✓ Attempt to lock more than balance (FAIL)
✓ Microtokens handled correctly (no rounding errors)

TEST FLOW:
1. Alice has 10,000 BB available
2. Alice locks 1,000 BB
3. Verify lock successful, balance = 9,000 BB
4. Alice locks another 5,000 BB
5. Verify balance = 4,000 BB, locked = 6,000 BB
6. Alice tries to lock 5,000 BB (only 4,000 available)
7. Should fail with insufficient balance

--------------------------------------------------------------------------------
TEST 6.3: SESSION TIMEOUT & EXPIRY
Status: [ ]
Priority: MEDIUM
Endpoint: GET /bridge/status/:id
File: sdk/test-session-expiry.js

WHAT IT TESTS:
- Do bridge locks expire after timeout?
- Are expired locks automatically released?
- Can users not withdraw expired locks?
- Is there grace period?

SUCCESS CRITERIA:
✓ Create lock with 1 hour expiry
✓ Query immediately (status: active)
✓ Query after expiry (status: expired)
✓ Funds auto-released back to available
✓ Cannot complete expired lock

TEST FLOW:
1. Create lock with expires_at = now + 10 seconds
2. Query status (should show active)
3. Wait 15 seconds
4. Query status (should show expired)
5. Attempt /bridge/complete (should fail)
6. Verify funds returned to available balance

================================================================================
PHASE 7: SOCIAL MINING (LOW PRIORITY)
================================================================================
Tests for social engagement and reward system.

--------------------------------------------------------------------------------
TEST 7.1: CREATE & LIKE POSTS
Status: [ ]
Priority: LOW
Endpoints: POST /social/post, POST /social/like
File: sdk/test-social-mining.js

WHAT IT TESTS:
- Can users create posts on-chain?
- Can users like posts?
- Are rewards distributed for engagement?
- Is spam prevented?

SUCCESS CRITERIA:
✓ Alice creates post
✓ Post stored on-chain
✓ Bob likes post
✓ Alice receives engagement reward
✓ Rate limiting prevents spam

TEST FLOW:
1. Alice posts "GM BlackBook!"
2. Post_id returned
3. Bob likes post
4. Alice receives 0.01 BB reward
5. Query /social/stats
6. Verify Alice has 1 post, 1 like received

--------------------------------------------------------------------------------
TEST 7.2: SOCIAL STATS & LEADERBOARD
Status: [ ]
Priority: LOW
Endpoint: GET /social/stats
File: sdk/test-social-stats.js

WHAT IT TESTS:
- Can we query social engagement stats?
- Is leaderboard sorted correctly?
- Are rewards accurately calculated?

SUCCESS CRITERIA:
✓ Stats show total posts, likes, rewards
✓ Leaderboard ranks by engagement score
✓ User stats accurate

TEST FLOW:
1. Multiple users create posts and interact
2. Query /social/stats
3. Verify totals match expected
4. Check leaderboard order

================================================================================
END-TO-END INTEGRATION TESTS
================================================================================

--------------------------------------------------------------------------------
TEST E2E-1: FULL BETTING FLOW (Alice vs Bob Coinflip)
Status: [ ]
Priority: CRITICAL
Endpoints: Multiple (full flow)
File: sdk/test-e2e-betting-flow.js

WHAT IT TESTS:
This is the complete user journey from wallet creation to bet settlement.

FULL FLOW:
1. Alice creates wallet (10,000 BB)
2. Bob creates wallet (5,000 BB)
3. Alice locks 1,000 BB for L2 (/bridge/initiate)
4. Bob locks 500 BB for L2
5. L2 receives notifications (/bridge/complete)
6. Alice bets 100 BB on HEADS (COINFLIP_001)
7. Bob bets 100 BB on TAILS (COINFLIP_001)
8. Dealer fronts both bets (L1 reimburses from locked)
9. Coinflip resolves: HEADS wins
10. Alice receives 200 BB payout from Dealer
11. L2 records settlement on L1 (/rpc/settlement)
12. Alice withdraws 1,100 BB back to L1 (/bridge/withdraw)
13. Bob withdraws 400 BB back to L1 (lost 100 BB)
14. Verify final balances:
    - Alice: 10,100 BB (won 100 BB)
    - Bob: 4,900 BB (lost 100 BB)
    - Dealer: 100,000 BB (break-even)

SUCCESS CRITERIA:
✓ All steps complete without errors
✓ Balances reconcile perfectly
✓ Settlement recorded on L1
✓ No funds lost or created

--------------------------------------------------------------------------------
TEST E2E-2: DEALER SESSION (Multi-Bet Session)
Status: [ ]
Priority: CRITICAL
Endpoints: /bridge/start-session, /bridge/settle-session
File: sdk/test-e2e-dealer-session.js

WHAT IT TESTS:
The new dealer model with session-based settlement.

FULL FLOW:
1. Alice starts session with 2,000 BB
2. Alice places 10 bets over 30 minutes:
   - 5 bets win (1,000 BB profit)
   - 5 bets lose (1,000 BB loss)
   - Net: break-even
3. Alice finishes session
4. L2 posts settlement: final_balance = 2,000 BB (no change)
5. L1 releases 2,000 BB back to Alice's available
6. Verify Alice balance = 10,000 BB (same as start)

SUCCESS CRITERIA:
✓ Session tracks all bets
✓ NET P&L calculated correctly
✓ Dealer pool balanced
✓ Alice's L1 balance correct after session

================================================================================
TEST EXECUTION TRACKER
================================================================================

PHASE 1 - CRITICAL CORE:
[ ] 1.1 - Token Transfers
[ ] 1.2 - Authentication
[ ] 1.3 - Balance Queries
[ ] 1.4 - Admin Minting

PHASE 2 - BRIDGE:
[✓] 2.1 - Bridge Lock (PASSED)
[ ] 2.2 - Bridge Status
[ ] 2.3 - Bridge Complete
[ ] 2.4 - Bridge Withdraw
[ ] 2.5 - Settlement Merkle

PHASE 3 - DEALER MODEL:
[ ] 3.1 - Start Session
[ ] 3.2 - L1 Balance Query
[ ] 3.3 - Settle Session
[ ] 3.4 - Dealer Reimbursement

PHASE 4 - CROSS-LAYER:
[ ] 4.1 - Signature Verification
[ ] 4.2 - Nonce Management
[ ] 4.3 - Record Settlement
[ ] 4.4 - Relay Action

PHASE 5 - SECURITY:
[ ] 5.1 - SSS Recovery
[ ] 5.2 - MPC Signing
[ ] 5.3 - Replay Protection

PHASE 6 - PERFORMANCE:
[ ] 6.1 - Concurrent Transfers
[ ] 6.2 - Large Bridge
[ ] 6.3 - Session Expiry

PHASE 7 - SOCIAL:
[ ] 7.1 - Posts & Likes
[ ] 7.2 - Social Stats

END-TO-END:
[ ] E2E-1 - Full Betting Flow
[ ] E2E-2 - Dealer Session

================================================================================
PROGRESS: 1/24 Tests Passed (4%)
Next Test: 1.1 - Token Transfers
================================================================================
